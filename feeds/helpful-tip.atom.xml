<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Carson Farmer</title><link href="http://www.carsonfarmer.com/" rel="alternate"></link><link href="http://www.carsonfarmer.com/feeds/helpful-tip.atom.xml" rel="self"></link><id>http://www.carsonfarmer.com/</id><updated>2010-04-21T15:34:00-04:00</updated><entry><title>Parallel bootstrapping withÂ R</title><link href="http://www.carsonfarmer.com/2010/04/parallel-bootstrapping-with-r/" rel="alternate"></link><updated>2010-04-21T15:34:00-04:00</updated><author><name>cfarmer</name></author><id>tag:www.carsonfarmer.com,2010-04-21:2010/04/parallel-bootstrapping-with-r/</id><summary type="html">&lt;p&gt;In a &lt;a href="http://www.carsonfarmer.com/2009/10/community-structure-in-directed-weighted-networks/"&gt;recent post&lt;/a&gt;, I mentioned that I was testing the stability of
clusters generated from a modified network partitioning algorithm using
bootstrap resampling techniques. I also mentioned that I was doing this
in R, using the very nice &lt;a href="http://cran.r-project.org/web/packages/foreach/index.html"&gt;foreach&lt;/a&gt; package published by &lt;a href="http://www.revolution-computing.com/"&gt;REvolution
Computing&lt;/a&gt;. To show just how nice this package is, below is a minimal
example of bootstrapping a network partitioning algorithm which takes
advantage of a multicore processor:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;library&lt;span class="p"&gt;(&lt;/span&gt;doMC&lt;span class="p"&gt;)&lt;/span&gt;
library&lt;span class="p"&gt;(&lt;/span&gt;foreach&lt;span class="p"&gt;)&lt;/span&gt;
library&lt;span class="p"&gt;(&lt;/span&gt;igraph&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Jaccard coeficcient function (taken from package fpc)&lt;/span&gt;
clujaccard &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;c1&lt;span class="p"&gt;,&lt;/span&gt; c2&lt;span class="p"&gt;,&lt;/span&gt; zerobyzero &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;NA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;sum&lt;span class="p"&gt;(&lt;/span&gt;c1&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; sum&lt;span class="p"&gt;(&lt;/span&gt;c2&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; sum&lt;span class="p"&gt;(&lt;/span&gt;c1 &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; c2&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        out &lt;span class="o"&gt;=&lt;/span&gt; zerobyzero
    &lt;span class="kr"&gt;else&lt;/span&gt;
        out &lt;span class="o"&gt;=&lt;/span&gt; sum&lt;span class="p"&gt;(&lt;/span&gt;c1 &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; c2&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;sum&lt;span class="p"&gt;(&lt;/span&gt;c1&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; sum&lt;span class="p"&gt;(&lt;/span&gt;c2&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; sum&lt;span class="p"&gt;(&lt;/span&gt;c1 &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; c2&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;out&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
registerDoMC&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# registers the parallel backend&lt;/span&gt;
B &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1000&lt;/span&gt; &lt;span class="c1"&gt;# number of bootstrap replicates to create&lt;/span&gt;
load&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;igraph_network.Rdata&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# load a previously saved network (network name: g)&lt;/span&gt;
fg &lt;span class="o"&gt;=&lt;/span&gt; fastgreedy.community&lt;span class="p"&gt;(&lt;/span&gt;g&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# compute original clustering&lt;/span&gt;
mm &lt;span class="o"&gt;=&lt;/span&gt; which.max&lt;span class="p"&gt;(&lt;/span&gt;fg&lt;span class="o"&gt;$&lt;/span&gt;modularity&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# find level of max modularity&lt;/span&gt;
moc &lt;span class="o"&gt;=&lt;/span&gt; community.to.membership&lt;span class="p"&gt;(&lt;/span&gt;g&lt;span class="p"&gt;,&lt;/span&gt; fg&lt;span class="o"&gt;$&lt;/span&gt;merges&lt;span class="p"&gt;,&lt;/span&gt; mm&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;membership &lt;span class="c1"&gt;# get membership&lt;/span&gt;
noc &lt;span class="o"&gt;=&lt;/span&gt; length&lt;span class="p"&gt;(&lt;/span&gt;unique&lt;span class="p"&gt;(&lt;/span&gt;moc&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# count the number original clusters&lt;/span&gt;
bg &lt;span class="o"&gt;=&lt;/span&gt; g &lt;span class="c1"&gt;# make a copy of g for bootstrapping&lt;/span&gt;
clusters &lt;span class="o"&gt;=&lt;/span&gt; foreach&lt;span class="p"&gt;(&lt;/span&gt;i&lt;span class="o"&gt;=&lt;/span&gt;seq&lt;span class="p"&gt;(&lt;/span&gt;B&lt;span class="p"&gt;),&lt;/span&gt; .combine&lt;span class="o"&gt;=&lt;/span&gt;cbind&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%dopar%&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    E&lt;span class="p"&gt;(&lt;/span&gt;bg&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;weight &lt;span class="o"&gt;=&lt;/span&gt; sample&lt;span class="p"&gt;(&lt;/span&gt;E&lt;span class="p"&gt;(&lt;/span&gt;g&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;weight&lt;span class="p"&gt;,&lt;/span&gt; replace&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# resample the edge weights&lt;/span&gt;
    fg &lt;span class="o"&gt;=&lt;/span&gt; fastgreedy.community&lt;span class="p"&gt;(&lt;/span&gt;bg&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# compute bootstrap clustering&lt;/span&gt;
    mm &lt;span class="o"&gt;=&lt;/span&gt; which.max&lt;span class="p"&gt;(&lt;/span&gt;fg&lt;span class="o"&gt;$&lt;/span&gt;modularity&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# find level of max modularity&lt;/span&gt;
    mbc &lt;span class="o"&gt;=&lt;/span&gt; community.to.membership&lt;span class="p"&gt;(&lt;/span&gt;bg&lt;span class="p"&gt;,&lt;/span&gt; fg&lt;span class="o"&gt;$&lt;/span&gt;merges&lt;span class="p"&gt;,&lt;/span&gt; mm&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;membership &lt;span class="c1"&gt;# get membership&lt;/span&gt;
    nbc &lt;span class="o"&gt;=&lt;/span&gt; length&lt;span class="p"&gt;(&lt;/span&gt;unique&lt;span class="p"&gt;(&lt;/span&gt;mbc&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# count the number new clusters&lt;/span&gt;
   Â bootresult &lt;span class="o"&gt;=&lt;/span&gt; c&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="kr"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;j &lt;span class="kr"&gt;in&lt;/span&gt; seq&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; noc&lt;span class="m"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;# for each of the original clusters...&lt;/span&gt;
        maxgamma &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
        &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;nbc &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kr"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;k &lt;span class="kr"&gt;in&lt;/span&gt; seq&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; nbc&lt;span class="m"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;# for each of the new clusters...&lt;/span&gt;
                bv &lt;span class="o"&gt;=&lt;/span&gt; as.vector&lt;span class="p"&gt;(&lt;/span&gt;mbc &lt;span class="o"&gt;==&lt;/span&gt; k&lt;span class="p"&gt;)&lt;/span&gt;
                ov &lt;span class="o"&gt;=&lt;/span&gt; as.vector&lt;span class="p"&gt;(&lt;/span&gt;moc &lt;span class="o"&gt;==&lt;/span&gt; j&lt;span class="p"&gt;)&lt;/span&gt;
                jc &lt;span class="o"&gt;=&lt;/span&gt; clujaccard&lt;span class="p"&gt;(&lt;/span&gt;ov&lt;span class="p"&gt;,&lt;/span&gt; bv&lt;span class="p"&gt;,&lt;/span&gt; zerobyzero&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;jc &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; maxgamma&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# if these two clusters are most similar...&lt;/span&gt;
                    maxgamma &lt;span class="o"&gt;=&lt;/span&gt; jc
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        bootresult &lt;span class="o"&gt;=&lt;/span&gt; c&lt;span class="p"&gt;(&lt;/span&gt;bootresult&lt;span class="p"&gt;,&lt;/span&gt; maxgamma&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# combine results&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;return&lt;/span&gt; bootresult &lt;span class="c1"&gt;# return the results of this iteration (and cbind with the rest)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
bootmean &lt;span class="o"&gt;=&lt;/span&gt; apply&lt;span class="p"&gt;(&lt;/span&gt;clusters&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; mean&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# mean Jaccard coefficient for each cluster&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The above example might not produce great results, as it simply
resamples (with replacement) the weights of all the network edges, and
therefore a more sophisticated resampling regime might be warranted.
Having said that, it&amp;#8217;s quite a useful example, and as you can see, the
only &amp;#8216;extra&amp;#8217; bits required to make this run on multiple cores is the
&lt;code&gt;registerDoMC()&lt;/code&gt; command which simply registers the parallel backend
(uses the multicore package) and the &lt;code&gt;foreach ... %dopar%&lt;/code&gt; which tells &lt;code&gt;R&lt;/code&gt;
to run the loops in parallel. I ran a similar analysis using a different
community detection algorithm on a computer with 4 cores, and was
(finally) able to take full advantage of my processing&amp;nbsp;power:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.carsonfarmer.com/images/foreachcpu.png"&gt;&lt;img alt="cpu_usage" src="http://www.carsonfarmer.com/images/foreachcpu-300x114.png" title="foreachcpu" /&gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="Bootstrapping"></category><category term="Cluster"></category><category term="Networks"></category><category term="R"></category><category term="Free open-source software (FOSS)"></category><category term="How to"></category><category term="Networks"></category><category term="Research"></category></entry></feed>